.. role:: red 
.. role:: blue 
.. role:: brown 
.. role:: remark
.. role:: worktodo
.. role:: slide
.. role:: slide1
.. role:: slide2
.. role:: slide3

.. _SpringBoot: https://spring.io/projects/spring-boot
.. _Applicazione web: https://it.wikipedia.org/wiki/Applicazione_web    
.. _WebappFrameworks: https://www.geeksforgeeks.org/top-10-frameworks-for-web-applications/
.. _Springio: https://spring.io/
.. _WebSocket: https://it.wikipedia.org/wiki/WebSocket
.. _Node.js: https://nodejs.org/it/
.. _Express: https://expressjs.com/it/
.. _CleanArchitecture: https://clevercoder.net/2018/09/08/clean-architecture-summary-review
.. _Buster: https://www.raspberrypi.com/news/buster-the-new-version-of-raspbian/
.. _Bullseye: https://www.raspberrypi.com/news/raspberry-pi-os-debian-bullseye/
.. _REST : https://en.wikipedia.org/wiki/Representational_state_transfer
.. _HATEOAS: https://en.wikipedia.org/wiki/HATEOAS
.. _BannerTool: https://manytools.org/hacker-tools/ascii-banner/
.. _jQuery: https://www.w3schools.com/jquery/default.asp
.. _Thymeleaf: https://www.thymeleaf.org/
.. _SpringMVCModel: https://www.baeldung.com/spring-mvc-model-model-map-model-view
.. _Introduzione a Spring Boot: https://azure.microsoft.com/it-it/resources/cloud-computing-dictionary/what-is-java-spring-boot/

.. _WebSocket: https://it.wikipedia.org/wiki/WebSocket
.. _SockJs: https://openbase.com/js/sockjs/documentation#what-is-sockjs
.. _Bootstrap: https://getbootstrap.com/
.. _jsdelivr: https://www.jsdelivr.com/
.. _WebJars: https://mvnrepository.com/artifact/org.webjars
.. _WebJarsExplained: https://www.baeldung.com/maven-webjars 
.. _WebJarsDocs: https://getbootstrap.com/docs/5.1/getting-started/introduction/
.. _WebJarsExamples: https://getbootstrap.com/docs/5.1/examples/
.. _WebJarsContainer: https://getbootstrap.com/docs/5.1/layout/containers/
.. _Heart-beating: https://stomp.github.io/stomp-specification-1.2.html#Heart-beating


.. _springIntro23: ../../../../springIntro23 
.. _HIControllerDemo: ../../../../springIntro23/src/main/java/unibo/springIntro23/HIControllerDemo.java


==================================
SpringBootIntro
==================================  

:slide3:`progetto springIntro23`   

Lo sviluppo di una `Applicazione web`_ -> non può presceindere dall'uso di uno dei numerosi framework disponibili (si veda ad
esempio `WebappFrameworks`_ ->). 

Per il nostro legame con Java, può essere opportuno, per ora, fare 
riferimento a `Springio`_ ->. Tuttavia, una adeguata alternativa potrebbe essere l'uso di framework basati su 
`Node.js`_ ->. ed `Express`_ ->.

Sappiamo che l'uso di un framework aiuta a risolvere problemi ricorrenti in un dominio e 
impone precise regole per l'introduzione di componenti applicativi 
nel contesto dello schema architetturale che il framework utilizza per supportare le sue funzionalità.

:slide:`Applicazioni Web: concetti di base`

-------------------------------------
Concetti di base
-------------------------------------

Nel caso dei framework nel dominio delle applicazioni Web, troviamo un insieme di concetti e modi di operare comuni:

- l'uso di un WebServer (spesso Apache Tomcat) che rimane nascosto al livello applicativo;
- l'uso di una infrastruttura che abilita le comunicazioni Client-Server mediante il protocollo HTTP 
  e gli schemi REST di interazione;
- la possibilità di definire componenti applicativi 'innestabili' nel framework secondo precisi meccanismi. 
  `SpringBoot`_ -> si basa principalmente sul meccanismo delle :ref:`Annotazioni` Java;
- il concetto di :blue:`Controller` come elemento-base per la gestione dei messaggi;
- l'uso di tools che agevolano la creazione dinamica di pagine HTML a partire da template con 'parametri'
  che possono essere fissati dal :blue:`Controller`;
- l'abilitazione all'uso delle WebSocket per interazioni asincrone con i Client  

Lo schema di funzionamento può essere riassunto come segue:

#. un operatore umano usa un Browser per collegarsi  (:blue:`Human-Machine interaction` :slide1:`HMI`) via HTTP 
   a una certa porta di un nodo remoto, usata come porta di ingresso dal WebServer
#. l'infrastruttura del framework effettua una prima gestione del messaggio in arrivo in modo da confezionare
   oggetti computazionali (richieste e/o risposte) da trasferire ad opportuni metodi del :blue:`Controller` 
   per agevolare la stesura del codice di gestione da parte dell'Application Designer. Spesso la perte infrastrutturale
   è organizzata secondo una **pipeline** che permette all'Application Designer di introdurre parti di elaborazione
   a questo livello
#. i metodi del :blue:`Controller` realizzano la gestione dei messaggi in funzione dei i 'verbi' HTTP (GET,PUT,POST,DELETE) 
   con cui sono stati inviati e prepara una pagina HTML di risposta, sfruttando opportuni template predefiniti di pagine.

+++++++++++++++++++++++++++++++++
Modello della pagina
+++++++++++++++++++++++++++++++++

   I :brown:`parametri dei template` vengono fissati utilizzando un **Modello della pagina** secondo un classico  
   :slide2:`schema Model View Controller`.

   In `SpringBoot`_ ->, il modello fornisce attributi utilizzati per il rendering delle viste: si veda
   `SpringMVCModel`_ ->.
   
#. il :blue:`Controller` restituisce la pagina alla parte infrastruttrale che l'aveva chiamato, la quale provvede a inviare
   la pagina al Client che aveva effettuato la richiesta HTTP;
#. se l'operatore umano è sostituito da una macchina  si parla di :blue:`Machine-To-Machine` (:slide1:`M2M`) interaction.
   I messaggi vengono girati a un :blue:`Controller` specializato per inviare ripsoste in forma di dati, molto spesso 
   in formato XML o JSon.


---------------------------------------
Architettura del WebServer
---------------------------------------

Dal punto di vista architetturale, l'organizzazione interna del codice del WebServer dovrà essere ispirata ai principi della
`CleanArchitecture`_.

:slide1:`CleanArchitecture`

.. csv-table::  
    :align: center
    :widths: 50,50
    :width: 100% 
    
    .. image:: ./_static/img/Architectures/cleanArchCone.jpg,.. image:: ./_static/img/Architectures/cleanArch.jpg

In accordo al principio della `inversione delle dipendenze <https://en.wikipedia.org/wiki/Dependency_inversion_principle>`_ ->:

- :remark:`I componenti di alto livello non devono dipendere da componenti di livello più basso.`


 Il concetto di :blue:`inversione` non significa che i livelli di livello inferiore dipendano direttamente dai livelli di livello superiore.
 Entrambi i livelli dovrebbero dipendere da :blue:`astrazioni` (*interfacce*) che espongono il comportamento richiesto 
 dai livelli di livello superiore.


Con queste premesse, il compito che ci attende è, in generale, quello di realizzare la parte 
**Presenter**,  in modo da continuare a tenere separati i casi d'uso dall'interfaccia utente.

:slide1:`Componenti-base`

Come ogni applicazione `SpringBoot`_ ->, gli elementi salienti sono:

- :slide2:`Il Controller`: Un WebServer Controller che si occupa della Human-Interaction  (che di norma denomineremo **HIController**) 
  che presenta all'end user una pagina HTML.
- :slide2:`La pagina HTML`: Una pagina HTML  che include campi il cui valore può essere definito attraverso
  un oggetto ``org.springframework.ui.Model`` che viene trasferito a  ``HIController`` dalla infrastruttura
  Spring e gestito mediante la Java template engine ``Theamleaf``.
- :slide2:`Funzioni JavaScript`: Un file JavaScript  che include funzioni utili per la gestione della pagina lato client.
- :slide2:`Le WebSocket`: l'suo  delle `WebSocket`_ ->, per l'aggiornamento automatico della pagina 
  da parte del server. 
  Per poter utilizzare le `WebSocket`_ ->,  `SpringBoot`_ -> richiede l'introduzione Un componente  
  che implementa l'interfaccia ``WebSocketConfigurer`` 
  di  *org.springframework.web.socket.config.annotation*. 
  Per un esempio, si veda :ref:`Configurazione con WebSocketConfigurer`.


:slide:`Introduzione all'uso di SpringBoot`

-----------------------------------------------
Primi passi con SpringBoot
-----------------------------------------------
:slide3:`progetto springIntro23`  `springIntro23`_

 

Spring Boot da ``3.0.0`` in avanti richiede ``Java 17`` come versione minima. Poichè noi usiamo Java 8 o 11, 
:slide3:`ci dovremo attenere alla serie di rilascio  2.x`.

:slide1:`Usiamo pring initializr`

#. Connettersi a https://start.spring.io/ 
#. Selezionare ``Gradle-Groovy``, ``Java``, ``2.7.8`` Group= ``unibo``, Artifact= ``springIntro23`` (Options:Packaging=``Jar``, Java=``8``) 
   e le seguenti Dipendenze:

   - :blue:`Spring Web`: crea applicazioni Web, inclusi RESTful, utilizzando Spring MVC. Utilizza Apache Tomcat come contenitore incorporato predefinito.
   - :blue:`Thymeleaf`: `Thymeleaf`_ è un moderno motore di template Java lato server per ambienti web e standalone,
     che mira a fornire un modo elegante e altamente gestibile per creare modelli. 
     Consente di visualizzare correttamente l'HTML nei browser e come prototipi statici.
   - :blue:`Spring Boot DevTools`: Fornisce riavvii rapidi delle applicazioni, LiveReload e configurazioni per un'esperienza di sviluppo avanzata. 
     Accelera questo ciclo di aggiornamento (codifica di una modifica, riavvio dell'applicazione e aggiornamento del browser 
     per visualizzare la modifica).

#. Attivare **Generate**
#. Decomprimiere il file generato ``springIntro23.zip`` in una directory vuota ed esegure
 
   ``gradlew build``

+++++++++++++++++++++++++++++++++
Progetto springIntro23
+++++++++++++++++++++++++++++++++

Si noti il file generato ``build.gradle`` include le seguenti dipendenze:

.. code::

   plugins {
      id 'java'
      id 'org.springframework.boot' version '2.7.8'
      id 'io.spring.dependency-management' version '1.0.15.RELEASE'
   }

   dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
   }

#. Aprire un IDE e aprire o importare il progetto `springIntro23`_. 
   Osservare la classe generata ``unibo.springIntro23.SpringIntro23Application.java``

    .. code:: Java

        package unibo.springIntro23;
        import org.springframework.boot.autoconfigure.SpringBootApplication
        import org.springframework.boot.runApplication

        @SpringBootApplication
        public class springIntro23Application {

        public static void main(String[] args) {
		      SpringApplication.run(springIntro23Application.class, args);
	      }

#. Eseguire l'applicazione (``gradlew bootrun``) e aprire un browser su  ``localhost:8080``: compare la pagina che segue:

   .. image::  ./_static/img/Spring/springboot1.PNG
     :align: center 
     :width: 50%


:slide1:`Verso una prima applicazione`

#. Creare il file ``springIntro23\src\main\resources\templates\welcome.html`` con il seguente contenuto:

   .. code:: Html

    <html xmlns:th="http://www.thymeleaf.org"> 
    <head><title>Welcome</title></head>
    <body>
    <h1>Welcome (in templates)</h1>
    <p>Welcome to <b><span th:text="${arg}">Our Arg</span></b>.</p>
    </body>
    </html>

   :slide2:`th:`: `Thymeleaf`_  sostituisce  il valore risultante dalla valutazione di :blue:`${arg}`
   durante l'elaborazione del modello della pagina.

#. Inserire nel file ``springIntro23\src\main\resources\application.properties`` quanto segue:

   .. code:: 

      spring.application.name=springIntro23

      spring.banner.location=classpath:banner.txt
      server.port   = 8085
      human.logo    = Gui for human-machine interaction
      machine.logo  = Gui for machine-to-machine interaction

#. Inserire nella ``directory resources`` un file ``banner.txt``  personalizzato ( si veda `BannerTool`_, Font ``Small``).  


:slide2:`Un primo controller`

+++++++++++++++++++++++++++++++++++++++++++++
HIControllerDemo 
+++++++++++++++++++++++++++++++++++++++++++++

Per introdurre un primo controller, creiamo (nel package ``unibo.springIntro23``) un file `HIControllerDemo`_ con il seguente contenuto:

.. code:: 

    package unibo.springIntro23;
    import ...
    
    @Controller //ANNOTAZIONE IMPORTANTE
    public class HIControllerDemo { 
    @Value("${spring.application.name}")
    String appName;

    @GetMapping("/") 		 
    public String homePage(Model model) {
        model.addAttribute("arg", appName);
        return "welcome";
    } 
            
    @ExceptionHandler 
    public ResponseEntity handle(Exception ex) {
            HttpHeaders responseHeaders = new HttpHeaders();
        return new ResponseEntity(
              "HIControllerDemo ERROR " + ex.getMessage(), 
              responseHeaders, HttpStatus.CREATED);
        }
    }

Attiviamo di nuovo l'applicazione e un browser su ``localhost:8085``. Vedremo comparire:

.. image::  ./_static/img/Spring/springboot2.PNG
  :align: center 
  :width: 60%





:slide1:`Usiamo le WebSocket`

------------------------------
SpringBootWebSocket
------------------------------


.. https://www.dariawan.com/tutorials/spring/spring-boot-websocket-basic-example/

Come primo semplice esempio di uso di :ref:`WebSocket` in Spring, creiamo una applicazione che consente
a un client di utilizzare un browser per inviare un messaggio o una immagine a un server 
che provvede a visualizzare il messaggio o l'immagine presso tutti i client collegati.

.. _SetupNoStomp:

+++++++++++++++++++++++++++++++++++++++++++++++
Usare le WebSocket in SpringBoot
+++++++++++++++++++++++++++++++++++++++++++++++

Con riferimento al progetto :ref:`Progetto springIntro23` inseriamo nel file ``build.gradle`` la seguente dipendenza:

.. code::

    repositories {
        mavenCentral()
        flatDir { dirs '../unibolibs' }
    }

   dependencies {
    ...
    //Added for WebSocket
    implementation 'org.springframework.boot:spring-boot-starter-websocket'
    //JSON
     implementation 'com.googlecode.json-simple:json-simple:1.1.1'
    //CUSTOM unibo
	implementation name: 'unibo.basicomm23-1.0'
   }


:slide2:`Operiamo senza un Controller`

-  Inseriamo un file ``index.html`` in **resources/static** per poter lanciare un'applicazione che 
   presenta un'*area  di ouput* per la visualizzazione di messaggi e un'*area di input* per la loro 
   immissione. 

.. _index:

+++++++++++++++++++++++++++++++++++++++++++++++
Il file static/index.html
+++++++++++++++++++++++++++++++++++++++++++++++

    .. code:: 

        <html>
        <head>
            <title>static/index</title>
        </head>

        <body>
        <h1>Welcome in static/index.html</h1>
           
        <textarea id="messageArea" name="messageArea" rows="10" cols="60">
        </textarea>

        <div>
            <p>Type a message and hit send:</p>
            <input id="inputmessage"/><button id="sendMessage">Send</button>
        </div>

        <script src="wsminimal.js"></script>
        </body>
        </html>

-  In questo caso, l'applicazione funzionerà anche senza la introduzione di un Controller,
   in quanto Spring utilizza di default il file ``resources/static/index.html``. 
   
   Per fare una prova, :remark:`commentiamo l'annotazione @Controller` in :ref:`HIControllerDemo`, 
   rilanciamo l'applicazione e  apriamo su un browser con ``localhost:8085``.



.. Notiamo che l'applicazione funziona anche in assenza di un controller, in quanto Spring utilizza di default il file **resources/static/index.html**.

La pagina si presenta come segue:

.. image:: ./_static/img/Spring/pageMinimal.PNG
    :align: center
    :width: 50%

Se invece è presente il controller :ref:`HIControllerDemo`, allora apriamo in un browser la pagina 
``http://localhost:8085/index.html``.
    


:slide1:`Funzioni JS nella pagina`

.. _wsminimal:

+++++++++++++++++++++++++++++++++++++++++++++++
Lo script wsminimal.js
+++++++++++++++++++++++++++++++++++++++++++++++

Lo script  ``resource/static/wsminimal.js`` definisce funzioni che realizzano la connessione con il server
e funzioni di ``I/O`` che permettono di inviare un messaggio al server e di visualizzare la risposta.


:slide2:`Funzioni per inviare e ricevere`
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Funzioni di connessione e ricezione messaggi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

- *connect*: effettua una connessione alla WebSocket e riceve i messaggi inviati dal server.

.. _connect:

.. code:: js

    var socket = connect();

    function connect(){
      var host     = document.location.host;
      var pathname =  document.location.pathname;
      var addr     = "ws://" +host + pathname + "socket"  ;

      // Assicura che sia aperta un unica connessione
      if(socket!==undefined && socket.readyState!==WebSocket.CLOSED){
        alert("WARNING: Connessione WebSocket già stabilita");
      }
      socket = new WebSocket(addr); //CONNESSIONE

      socket.onopen = function (event) {
        addMessageToWindow("Connected");
      };
      socket.onmessage = function (event) { //RICEZIONE
        addMessageToWindow(""+`${event.data}`);
      };
      return socket;
    }//connect

.. Si noti la struttura di codice già incontrata in Java.

:slide2:`Funzioni per aggiornare`

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Funzioni di input/output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. _sendMessage:

- *sendMessage*: invia un messaggio al server attraverso la socket 
- *addMessageToWindow* : visualizza un messaggio nella output area 

.. code:: js

    const messageWindow   = document.getElementById("messageArea");
    const messageInput    = document.getElementById("inputmessage");
    const sendButton      = document.getElementById("sendMessage");

    sendButton.onclick = function (event) {
        sendMessage(messageInput.value);
        messageInput.value = "";
    }
    function sendMessage(message) {
        var jsonMsg = JSON.stringify( {'name': message});
        socket.send(message);
    }
    function addMessageToWindow(message) {
        messageWindow.innerHTML += message  + "\n"
    }

:slide1:`Implementiamo WebSocketConfigurer`

+++++++++++++++++++++++++++++++++++++++++++++++
Configurazione con WebSocketConfigurer
+++++++++++++++++++++++++++++++++++++++++++++++

Affinché l'applicazione Spring inoltri le richieste di un client al server, 
è necessario registrare un gestore utilizzando una classe di configurazione 
che implementa l'interfaccia ``WebSocketConfigurer``.

.. code:: java

    @Configuration
    @EnableWebSocket
    public class WebSocketConfiguration implements WebSocketConfigurer {
    public static final WebSocketHandlerDemo wshandler = new WebSocketHandlerDemo();
    public static final String wspath                  = "socket";
      @Override
      public void registerWebSocketHandlers(WebSocketHandlerRegistry registry){
        registry.addHandler(wshandler, wspath).setAllowedOrigins("*");
      }
    }

L'annotazione ``@EnableWebSocket`` (da aggiungere a una classe qualificata ``@Configuration``)  
abilita l'uso delle plain WebSocket. 

In base alla configurazione :remark:`wspath="socket"` trasferita in fase di registrazione dell'handler
:ref:`WebSocketHandlerDemo<Il gestore WebSocketHandlerDemo>`, il server, avvalendosi di una istanza di ``WebSocketHandler``, 
risponderà a richieste inviate al seguente indirizzo:

.. code:: java

    ws://<serverIP>:8085/socket

:slide1:`Definiamo il gestore dei messaggi`

+++++++++++++++++++++++++++++++++++++++++++++++
Il gestore WebSocketHandlerDemo
+++++++++++++++++++++++++++++++++++++++++++++++

La classe  ``WebSocketHandlerDemo`` definisce un gestore custom di messaggi come specializzazione della classe astratta
``org.springframework.web.socket.handler.AbstractWebSocketHandler`` 
(o delle sue sottoclassi ``TextWebSocketHandler`` o ``BinaryWebSocketHandler``).    

.. code:: java

    public class WebSocketHandlerDemo 
        extends AbstractWebSocketHandler {//che implements WebSocketHandler interface
      
      private final List<WebSocketSession> sessions=new CopyOnWriteArrayList<>();
        ...
    }

:slide2:`Propaghiamo l'informazione dal server ai client`

+++++++++++++++++++++++++++++++++++++++++++++++
Propagazione a tutti i client
+++++++++++++++++++++++++++++++++++++++++++++++

Per propagare un messaggio a tutti i client connessi attraverso la WebSocket, basta tenere traccia
delle sessioni.

.. code:: java

    @Override  //AbstractWebSocketHandler
    public void afterConnectionEstablished(WebSocketSession session) throws Exception{
        sessions.add(session);
        super.afterConnectionEstablished(session);
    }
    @Override //AbstractWebSocketHandler
    public void afterConnectionClosed( WebSocketSession session, 
                            CloseStatus status) throws Exception{
        sessions.remove(session);
        super.afterConnectionClosed(session, status);
    }


Nel nostro caso, la gestione del messaggio ricevuto 
consiste nel reinviare sulla WebSocket il messaggio stesso.
Questa azione del server porrà in esecuzione sul client  l'operazione ``socket.onmessage`` 
(si veda `connect`_) che visualizzerà il messaggio nell'area di output.

.. code:: java

    @Override //AbstractWebSocketHandler
    protected void handleTextMessage(WebSocketSession session, 
                        TextMessage message) throws IOException{
        String cmd = message.getPayload();
        sendToAll("echo: "+cmd);
    }

    protected void sendToAll(TextMessage message) throws IOException{
        Iterator<WebSocketSession> iter = sessions.iterator();
        while( iter.hasNext() ){ iter.next().sendMessage(message);}
    }

+++++++++++++++++++++++++++++++++++++++++++++++
Un client in Java
+++++++++++++++++++++++++++++++++++++++++++++++
Definiamo un client in Java che usa
:ref:`ConnectionFactory<unibo.basicomm23.utils.ConnectionFactory>` per creare una connessione 
di tipo :ref:`WsConnection` con il server,
aggiungendo se stesso come osservaore sulla connessione.

.. code::

    public class TestClient extends ApplAbstractObserver {
        private Interaction2021 clientConn;

        public TestClient(){
            clientConn = ConnectionFactory.createClientSupport(
                    ProtocolType.ws, "localhost", "8085/socket"); //!!! NOTE 8085/socket
            ((WsConnection)clientConn ).addObserver(this);
        }

        @Override
        public void update(String s) {
            CommUtils.outblue("TestClient update=" + s);
        }

        public void doJob(){
            try {
                clientConn.forward("hello from Java client");
                CommUtils.outblue("TestClient forward done " );
                Thread.sleep(2000); //To sse the update
            } catch (Exception ex) {
                CommUtils.outred("TestClient ERROR: " + ex.getMessage());
            }
        }
        public static void main(String[] args) {
            TestClient appl = new TestClient();
            appl.doJob();
        }
    }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Esecuzione del client
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#. Attivare l'applicazione Spring ``SpringIntro23Application`` **SENZA Controller**
#. Aprire un browser su ``localhost:8085``
#. Attivare ``TestClient`` e osservare l'update  sulla output area della pagina


:slide:`Una prima applicazione`

--------------------------------------------
Un Controller applicativo
--------------------------------------------

L'introduzione di un Controller può essere utile per offire più funzionalità, come ad esempio
la possibilità di trasferire immagini.

:slide1:`Un controller più evoluto`


++++++++++++++++++++++++++++++++
HIControllerAppl
++++++++++++++++++++++++++++++++

Commentiamo l'annotazione ``@Controller`` in :ref:`HIControllerDemo` e definiamo un nuovo controller.

.. code::

    import org.springframework.ui.Model

    @Controller
    //@RequestMapping("/Api")
    public class HIControllerAppl {
        @Value("${spring.application.name}")
        String appName;

    @GetMapping("/")
    public String homePage(Model model) {
        model.addAttribute("arg", appName);
        return "GuiNoImages";
    }
    @GetMapping("/img")
    public String textOnly(Model model) {
        model.addAttribute("arg", appName);
        return "GuiAlsoImages";
    }


:slide1:`Una pagina per inviare messaggi`

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
GuiNoImages.html
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In **resource/templates** inseriamo un file simile a :ref:`index.html<Il file index.html>`, 
che include anche campi i cui valori
possono essere fissati dal controller (grazie a `Thymeleaf`_) mediante  il Model.


.. list-table::
  :widths: 50,50
  :width: 100%
  
  * - .. code::

        <html xmlns:th="http://www.thymeleaf.org">
        <head>
            <title>GuiNoImages</title>
        </head>

        <body>
        <h1>GuiNoImages</h1>
        <p>Welcome to 
        <b><span th:text="${arg}">Our Arg</span></b>.</p>
        <textarea id="messageArea" 
          name="messageArea" rows="10" cols="60">
        </textarea>

        <div>
            <p>Type a message and hit send:</p>
            <input id="inputmessage"/>
            <button id="sendMessage">Send</button>
        </div>

        <script src="../wsminimal.js"></script>
        </body>
        </html>
  
    - .. image:: ./_static/img/Spring/GuiNoImages.png
         :width: 100%


:slide1:`Una pagina per inviare anche immagini`

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
GuiAlsoImages.html
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Il file ``GuiAlsoImages.html`` definisce una pagina HTML che permette, oltre all'invio e ricezione di 
testi, il trasferimento di immagini.


.. list-table::
  :widths: 55,45
  :width: 100%
  
  * - Questo file:
  
      - fa uso di Bootstrap_, una libreria  utile per realizzare pagine web reattive e 
        mobile-first, con HTML, CSS e JavaScript; la libreria usa il preprocessore CSS 
        scritto in Ruby denominato ``Sass`` (*Syntactically Awesome Style Sheets*)
      - utilizza :ref:`Lo script wsalsoimages.js`
      - presenta all'utente:
        
        - pulsanti per la (dis)connessione alla WS (``URL=ws://<ServerIP>:8085/socket``)
        - pulsanti per l'invio di testi e di immagini
        - un'area di output per la visualizzazione di informazioni inviate dal server
  
    - .. image:: ./_static/img/Spring/GuiAlsoImages.png
         :width: 100%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Struttura generale del file GuiAlsoImages.html
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. code:: html

  <html>
  <head>
  <link href="/webjars/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <script src="/webjars/jquery/jquery.min.js"></script>
  <title>GuiAlsoImages</title>
  </head>
    <body>
    <div id="main-content" class="container-fluid pt-3">
      <h1>GuiAlsoImages</h1>
      <!-- Connessione/Disconnessione alla WebSocket -->
      <!-- Inserzione di testi e immagini            -->
      <!-- Area di output testuale                   -->
      <!-- Area per le immagini                      -->
    </div>
    </body>

Notiamo la necessità dell'uso di un WebJarsContainer_ come elemento-base del layout Bootstrap.

:slide2:`La libreria Bootstrap`


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Bootstrap  e webJars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

L'uso di Bootstrap_ avviene attraverso i WebJars_, introducendo in *build.gradle* le seguenti 
nuove dipendenze:

.. code:: 

	implementation 'org.webjars:webjars-locator-core'
	implementation 'org.webjars:bootstrap:5.1.3'
	implementation 'org.webjars:jquery:3.6.0'

I :blue:`WebJar` (che non sono legati a Spring) sono dipendenze lato client impacchettate in file JAR.
Per approfondire, si veda: WebJarsDocs_ e WebJarsExamples_.

:slide2:`Campi connect/disconnect`

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Connessione/Disconnessione alla WebSocket
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. list-table::
  :widths: 30,70
  :width: 100%
  
  * - La parte di pagina relativa alla (dis)connessione:
  
      .. image:: ./_static/img/Spring/connectGui.PNG 
         :align: center
         :width: 100%
     
      Si veda anche (su :ref:`wsalsoimages<Lo script wsalsoimages.js>`): 
      
      :ref:`Funzioni di (dis)connessione su webSocket`

      .. ref:`Funzioni di creazione della WebSocket`
  
    - viene prodotta come segue:

      .. code::  

        <div class="row">   
         <div class="col-md-6">
          <form class="form-inline">
            <div class="form-group">
              <label for="connect">WebSocket connection:</label>
              <button id="connect" class="btn btn-default" 
                        type="submit">Connect</button>
              <button id="disconnect" class="btn btn-default" 
                        type="submit" disabled="disabled">Disconnect
              </button>
            </div>
          </form>
         </div>
        </div>


:slide2:`Campi di invio testi/immagini`

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Inserzione di testi e immagini
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. list-table::
  :widths: 30,70
  :width: 100%
  
  * - La parte di pagina relativa ai pulsanti di invio:
  
      .. image:: ./_static/img/Spring/inputGui.PNG 
         :align: center
         :width: 100%
     
      Si veda anche: 
      
      :ref:`Funzioni di gestione pulsanti`

      .. :ref:`Funzioni di invio su WS`
  
    - viene prodotta come segue:

      .. code::  
 
        <div class="row">
        <div class="col-md-6">
            <form class="form-inline">
            <div class="form-group">
                <label for="inputmsg">Input (text)</label>
                <input type="text" id="inputmsg" 
                        class="form-control" placeholder="Input here...">
            </div>
            <button id="sendmsg" 
                class="btn btn-default" type="submit">Send text</button>
            </form>
        </div>
        </div>
        
        <div class="row">
            <div class="col-md-6">
            <form class="form-inline">
            <div class="form-group">
                <label for="myfile">Input (image)</label>
                <input type="file" id="myfile" name="myfile" 
                        class="form-control" accept="image/*"/>
            </div>
            <button id="sendImage" 
                class="btn btn-default" type="submit">Send Image</button>
            </form>
            </div>    
        </div>  


:slide2:`Aree di visualizzazione`

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Area di output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


.. list-table::
  :widths: 30,70
  :width: 100%
  
  * - La parte di pagina relativa all'area di output:
  
      .. image:: ./_static/img/Spring/outputGui.PNG 
         :align: center
         :width: 100%
     
      Si veda anche: 
      
      :ref:`Funzioni di invio su WS`
  
    - viene prodotta come segue:

      .. code::  html

        <div class="row">
         <div class="col-md-12">
            <table id="conversation" class="table table-striped">
             <thead>
              <tr>
                 <th>Output Area</th>
               </tr>
             </thead>
             <tbody id="output">
             </tbody>
            </table>
         </div>
        </div>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Area delle immagini
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. list-table::
  :widths: 30,70
  :width: 100%
  
  * - La parte di pagina relativa all'area delle immagini:
  
      .. image:: ./_static/img/Spring/imageGui.PNG 
         :align: center
         :width: 100%
     
      Si veda anche: 
      
      :ref:`Aggiornamento aree di output`
  
    - viene prodotta in modo simile a quanto fatto in :ref:`index.html<Il file index.html>`:

      .. code::  html
 
        <h5>Image area</h5>
        <hr/>
            <p id="imageArea"></p>

      Ciò in quanto si intende aggiornare quest'area ad ogni immagine.

:slide1:`Nuove funzioni in JS`

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Lo script wsalsoimages.js
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Lo script  ``wsalsoimages.js`` utilizza :ref:`jQuery` per realizzare funzioni:

- per la connessione/disconnessione mediante WebSocket: :ref:`Funzioni di (dis)connessione su webSocket`;
- per permettere all'utente di inserire messaggi e immagini da inviare al server mediante WebSocket:
  :ref:`Funzioni di gestione pulsanti`;
- per visualizzare informazioni ricevute dal server: :ref:`Aggiornamento aree di output`.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Riferimenti a oggetti della pagina
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. code:: js

    var socket;  //set by connect() called by the enduser
    var sockConnected = false;
    const imageWindow = document.getElementById("imageArea");
    const fileInput   = document.getElementById("myfile");

Gli elementi della pagina  ``imageArea`` e ``myfile`` sono ovviamwnte quelli definiti nel file
:ref:`GuiAlsoImages.html<Inserzione di testi e immagini>`.

:slide2:`Connessione/Disconnessione`


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Funzioni di (dis)connessione su webSocket
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Al caricamento della pagina si vuole sia attivo il solo pulsante **Connect**, che va disattivato 
(a favore di *Disconnect*) una volta premuto.
 
La creazione della WebSocket è accompagnata dalla definizione di callback relativi
alla apertura della socket e alla ricezione di messaggi dal server. 

.. code:: js

    function connect(){
        var host     = document.location.host;
        var pathname =  "/"; 	//document.location.pathname;
        var addr     = "ws://" + host  + pathname + "socket"  ;
   
        // Assicura che sia aperta un unica connessione
        if(socket !== undefined && socket.readyState !== WebSocket.CLOSED){
             console.log("Connessione WebSocket già  stabilita");
        }
 
        socket            = new WebSocket(addr);
        socket.binaryType = "arraybuffer";

        socket.onopen = function (event) {
        	setConnected(true);
            addMessageToWindow("Connected");
        };
        //RICEZIONE di messaggi dal server
        socket.onmessage = function (event) {
            if (event.data instanceof ArrayBuffer){ //Image
                setImageInWindow(event.data);
            } else {
                addMessageToWindow(`${event.data}`);
            }
        }
        socket.onclose = function (event) {
            alert("onclose event=" + event.reason)
            connect(); //AUTOMATIC RECONNECTION...
        }
    }//connect

    function disconnect() { setConnected(false); }

    function setConnected(connected) {
        $("#connect").prop("disabled", connected);
        $("#disconnect").prop("disabled", !connected);
        $("#output").html("");
    }

:slide2:`Gestione dei pulsanti`

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Funzioni di gestione pulsanti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 
.. code:: js

    $(function () {
        $("form").on('submit', function (e) { e.preventDefault(); });
        $( "#connect" ).click(function() { connect(); });
        $( "#disconnect" ).click(function() { disconnect(); });
        $( "#sendmsg" ).click(function() { sendMessage($("#inputmsg").val());});
        $( "#sendImage" ).click(function() {let f = fileInput.files[0]; sendMessage(f);});
    });

- ``$(function () { ... })`` è uno short-hand per invocare una funzione dopo che tutti gli elementi del DOM
  della pagina sono stati caricati, ed equivale a:

    .. code::

        $(document).ready(function() { ... });

- ``e.preventDefault()`` viene usato per evitare che un click su un pulsante inneschi 
  la navigazione verso l’URL da parte del browser. 
  
  In sua assenza, il server riinivierebbe la pagina, perdendo così gli aggiornamenti sulle aree di output.
 

.. Un click su un pulsante di invio di un form – inizializza l’invio dello stesso al server.

:slide2:`Invio messaggi su WS`

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Funzioni di invio su WS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. code:: js

    function sendMessage(message) {
        if( socket == null || ! sockConnected ) alert("Please connect ...");
        else socket.send(message);
    }
  

:slide2:`Output`

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Aggiornamento aree di output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ricordando :ref:`Riferimenti a oggetti della pagina`:

.. code:: js

        
    function addMessageToWindow(message) {
        $("#output").append("<tr><td>" + message + "</td></tr>");
     }


    function setImageInWindow(image) {
        let url = URL.createObjectURL(new Blob([image]));
        //Usando DOM
        //imageWindow.innerHTML = `<img src="${url}"/>`
        //Usando jQuery
        $("#imageArea").html(`<img src="${url}"/>`);
    }    


    //Volendo appendere una immagine nella outputArea ...
    function addImageToWindow(image) {
        let url = URL.createObjectURL(new Blob([image]));
        $("#output").append("<tr><td>" + 
            `<img src="${url}"/>` + "</td></tr>");
    }

--------------------------------------------------------
Flask vs Spring Boot: What are the differences?
--------------------------------------------------------

Flask and Spring Boot are two popular frameworks used for building web applications. Let's explore the key differences between Flask and Spring Boot.

#. **Language and Framework Compatibility**: Flask is a microframework for Python, allowing developers to have more control over the application structure. On the other hand, Spring Boot is built on top of the Java Spring framework, providing a full-stack solution for Java web development.

#. **Scope and Features**: Flask is known for its simplicity and lightweight nature, making it a popular choice for small to medium-sized applications. It provides only the essential features for web development, allowing developers to choose and add additional libraries or components as per their requirements. Spring Boot, on the other hand, comes with a wide range of features and integrations out-of-the-box, making it suitable for large-scale enterprise applications.

#. **Deployment and Containerization**: Flask applications can be deployed using any web server that supports the WSGI protocol, such as Apache or Nginx. Flask also provides a built-in development server for quick testing. Spring Boot, on the other hand, includes an embedded Tomcat or Undertow server, allowing application deployment as a standalone executable JAR file. This makes it easier to package and deploy Spring Boot applications as Docker containers.

#. **Community Ecosystem**: Flask has a smaller but active community, with a wide range of third-party libraries and extensions available through the Flask extension registry. However, compared to Spring Boot, the ecosystem for Flask is relatively smaller. Spring Boot has a large and mature community, with extensive documentation, tutorials, and a vast number of libraries available through Spring's official repository.

#. **Testing and Integration**: Flask provides a testing framework that makes it easy to write unit tests for applications. It also integrates well with third-party testing libraries like pytest and nose. Spring Boot, on the other hand, offers a comprehensive testing framework with support for unit testing, integration testing, and end-to-end testing. Spring Boot also has strong support for integration with popular testing frameworks like JUnit and Mockito.

#. **Database and ORM**: Flask provides support for various ORM (Object-Relational Mapping) libraries like SQLAlchemy and peewee, allowing developers to work with different databases. Spring Boot, on the other hand, has built-in support for the Spring Data JPA library, which offers seamless integration with different database technologies through the Hibernate ORM. Spring Boot also provides support for NoSQL databases like MongoDB through Spring Data MongoDB.

In summary, Flask is a lightweight and flexible framework for Python web development, while Spring Boot provides a full-stack solution for Java web development, with a wide range of features and integrations. Flask is often preferred for smaller projects or when the developers require more control and flexibility, while Spring Boot is suitable for large-scale enterprise applications with more extensive out-of-the-box functionality.    



-----------------------------------------------
Installate tyk
-----------------------------------------------

+++++++++++++++++++++++++++++++
Installare wget in Windows
+++++++++++++++++++++++++++++++

.. code::

  winget install wget


++++++++++++++++++++++++++++++++++++++++++++++
Installo tyk con docker
++++++++++++++++++++++++++++++++++++++++++++++

Riferimento dato nel libro **Machine-Learning-in-Microservices** (pg.164).

Usando cygwin64
mi metto in *C:/Didattica2024/qak24/WebGuiOutput/src/main/resources/flask* ed eseguo 
quanto riportato in https://tyk.io/docs/tyk-oss/ce-docker/

.. code::

  # WARNING, THIS WILL REMOVE ALL VOLUMES
  docker volume rm $(docker volume ls -q)

  #
  docker container prune 
  docker volume prune


  //Step 1 - Create a network
  docker network create tyk

  //Step 2 - Deploy Redis into the network, with the 6379 port open
  docker run -itd --rm --name tyk-redis --network tyk -p 127.0.0.1:6379:6379 redis:4.0-alpine

  //Step 3 - Next, let’s download a JSON tyk.conf configuration file
  wget https://raw.githubusercontent.com/TykTechnologies/tyk-gateway-docker/master/tyk.standalone.conf

  //Step 4 - Run the Gateway, mounting the conf file into the container
  docker run \
  --name tyk_gateway \
  --network tyk \
  -p 8080:8080 \
  -v C:/Didattica2024/qak24/WebGuiOutput/src/main/resources/flask/tyk.standalone.conf:/opt/tyk-gateway/tyk.conf \
  -v C:/Didattica2024/qak24/WebGuiOutput/apps:/opt/tyk-gateway/apps \
  docker.tyk.io/tyk-gateway/tyk-gateway:latest

 
  curl localhost:8080/hello
  {"status":"pass","version":"v4.0.0","description":"Tyk GW",
   "details":{"redis":{"status":"pass","componentType":"datastore",
   "time":"2024-08-06T15:41:08Z"}}}
